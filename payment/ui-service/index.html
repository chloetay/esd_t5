<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>E-Wallet Platform</title>
  <script src="https://js.stripe.com/v3/"></script>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      padding-top: 2rem;
    }
    .container {
      max-width: 800px;
    }
    .card {
      margin-bottom: 1.5rem;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    .btn-primary {
      background-color: #635BFF;
      border-color: #635BFF;
    }
    .btn-primary:hover {
      background-color: #5147D1;
      border-color: #5147D1;
    }
    #payment-history {
      max-height: 300px;
      overflow-y: auto;
    }
    .loading-spinner {
      display: inline-block;
      width: 1rem;
      height: 1rem;
      border: 0.2em solid currentColor;
      border-right-color: transparent;
      border-radius: 50%;
      animation: spinner-border .75s linear infinite;
    }
    @keyframes spinner-border {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1 class="mb-4 text-center">E-Wallet Platform</h1>

    <div class="row">
      <div class="col-md-6">
        <div class="card">
          <div class="card-header bg-light">
            <h5 class="mb-0">Wallet Balance</h5>
          </div>
          <div class="card-body">
            <h2 class="text-center" id="balance">Loading...</h2>
            <p class="text-center text-muted">Available Balance</p>
            <div class="d-grid">
              <button class="btn btn-outline-primary" onclick="refreshBalance()">Refresh Balance</button>
            </div>
          </div>
        </div>
      </div>

      <div class="col-md-6">
        <div class="card">
          <div class="card-header bg-light">
            <h5 class="mb-0">Top Up</h5>
          </div>
          <div class="card-body">
            <div class="mb-3">
              <label for="amount" class="form-label">Amount to Top Up:</label>
              <select id="amount" class="form-select">
                <option value="1000">$10.00</option>
                <option value="2000">$20.00</option>
                <option value="5000">$50.00</option>
              </select>
            </div>
            <div class="d-grid">
              <button class="btn btn-primary" onclick="handleCheckout()">Proceed to Checkout</button>
            </div>
            <div id="payment-status" class="mt-3 text-center"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="card mt-4">
      <div class="card-header bg-light">
        <h5 class="mb-0">Recent Transactions</h5>
      </div>
      <div class="card-body">
        <div id="payment-history">
          <div class="text-center text-muted">No transactions yet</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Direct Service URLs (assuming Docker host is localhost)
    const PAYMENT_SERVICE_BASE_URL = 'http://localhost:8083'; // Direct URL for payment-service
    const TRANSACTION_LOGS_SERVICE_BASE_URL = 'http://localhost:8005'; // Direct URL for transaction-logs-service

    // --- Wallet API still needs to go through Kong (or directly to external URL) ---
    // Kong base URL (only needed for external Wallet API proxy)
    const KONG_BASE_URL = 'http://localhost:9000'; // Or remove if calling Wallet API directly externally

    // Wallet API configuration (still points via Kong or needs direct external URL)
    const WALLET_API_URL = `${KONG_BASE_URL}/api/wallet/GetWallet`; // This proxies an external URL
    const WALLET_CREDENTIALS = {
      WalletId: 23,
      Password: "hello"
    };

    // Fetch wallet balance (remains unchanged, uses Kong for external proxy)
    async function fetchWalletBalance() {
      try {
        const response = await fetch(WALLET_API_URL, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(WALLET_CREDENTIALS)
        });

        if (!response.ok) {
          throw new Error(`API error: ${response.status}`);
        }

        const data = await response.json();
        console.log('Wallet API response:', data);

        if (data && typeof data.Balance !== 'undefined') {
          return data.Balance;
        } else if (data && typeof data.balance !== 'undefined') {
          return data.balance;
        } else {
          console.error('Unexpected API response format:', data);
          return null;
        }
      } catch (error) {
        console.error('Error fetching wallet balance:', error);
        return null;
      }
    }

    // Display formatted balance (unchanged)
    function updateBalanceDisplay(balance) {
      if (balance === null) {
        document.getElementById('balance').textContent = 'Error loading balance';
        return;
      }

      const formattedBalance = new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD'
      }).format(balance * 100); // Assuming balance is in dollars, format requires cents? Check Wallet API response. Or if already cents / 100. Needs verification based on actual API. Let's assume the original calculation was correct.

      document.getElementById('balance').textContent = formattedBalance;
    }

    // Refresh balance from API (unchanged)
    async function refreshBalance() {
      document.getElementById('balance').innerHTML = '<div class="loading-spinner"></div> Loading...';
      const balance = await fetchWalletBalance();
      updateBalanceDisplay(balance);
    }

    // Handle checkout process (calls payment-service directly)
    async function handleCheckout() {
      const amount = document.getElementById('amount').value;
      const statusElement = document.getElementById('payment-status');
      const checkoutButton = document.querySelector('.btn-primary');

      statusElement.innerHTML = '<div class="loading-spinner"></div> Processing...';
      checkoutButton.disabled = true;

      localStorage.removeItem('session_id');
      localStorage.removeItem('last_payment_id');

      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 15000);

        // *** CHANGED URL TO DIRECT PAYMENT SERVICE ***
        const response = await fetch(`${PAYMENT_SERVICE_BASE_URL}/create-checkout-session`, { //
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            amount: parseInt(amount),
            currency: 'usd',
            wallet_id: WALLET_CREDENTIALS.WalletId.toString(),
            metadata: {
              product_type: 'wallet_topup',
              wallet_id: WALLET_CREDENTIALS.WalletId,
              email: 'user@example.com' // Add a default email for wallet update
            }
          }),
          signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
          throw new Error(`Server error: ${response.status}`);
        }

        const data = await response.json();

        if (data.checkout_url) {
          localStorage.setItem('last_payment_id', data.payment_id);
          localStorage.setItem('session_id', data.session_id);
          localStorage.setItem('topup_amount', amount);

          window.location.href = data.checkout_url;
        } else {
          throw new Error('No checkout URL in response');
        }

      } catch (err) {
        let errorMessage = 'An error occurred';
        if (err.name === 'AbortError') {
          errorMessage = 'Request timed out. Please try again.';
        } else if (err.message) {
          errorMessage = err.message;
        }

        statusElement.innerHTML = `<div class="alert alert-danger">${errorMessage}</div>`;
        console.error('Checkout error:', err);

        setTimeout(() => {
          statusElement.innerHTML = '';
        }, 5000);
      } finally {
        checkoutButton.disabled = false;
      }
    }

    // Load transaction history (calls transaction-logs-service directly)
    async function loadTransactionHistory() {
      try {
        // *** CHANGED URL TO DIRECT TRANSACTION LOGS SERVICE ***
        // Using the /user/{wallet_id} endpoint directly
        const response = await fetch(`${TRANSACTION_LOGS_SERVICE_BASE_URL}/user/${WALLET_CREDENTIALS.WalletId}`, {
          headers: {
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache'
          }
        });

        if (!response.ok) {
            // Attempt fallback path if the first one fails
             const fallbackResponse = await fetch(`${TRANSACTION_LOGS_SERVICE_BASE_URL}/api/transaction-logs/user/${WALLET_CREDENTIALS.WalletId}`, { //
                headers: { 'Cache-Control': 'no-cache', 'Pragma': 'no-cache' }
             });
             if (!fallbackResponse.ok) {
                 throw new Error(`Error fetching history: ${response.status} & ${fallbackResponse.status}`);
             }
             transactions = await fallbackResponse.json();
        } else {
             transactions = await response.json();
        }

        // const transactions = await response.json(); // Original line before fallback logic
        const historyElement = document.getElementById('payment-history');
        historyElement.innerHTML = ''; // Clear existing content

        if (transactions.length === 0) {
          historyElement.innerHTML = '<div class="text-center text-muted">No transactions yet</div>';
        } else {
          // Group transactions by payment_id
          const groupedTransactions = {};

          // First, group all transactions by their payment_id
          transactions.forEach(tx => {
            if (!groupedTransactions[tx.payment_id]) {
              groupedTransactions[tx.payment_id] = [];
            }
            groupedTransactions[tx.payment_id].push(tx);
          });

          // For each group, strictly prioritize "completed" transactions
          const uniqueTransactions = Object.values(groupedTransactions).map(group => {
            // Always prioritize completed transactions first
            const completedTransactions = group.filter(tx => tx.status === "completed");

            if (completedTransactions.length > 0) {
              // If there are multiple completed transactions, get the most recent one
              completedTransactions.sort((a, b) =>
                new Date(b.completed_at || b.created_at) - new Date(a.completed_at || a.created_at)
              );
              return completedTransactions[0];
            }

            // If no completed transaction exists, return the most recent one
            group.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
            return group[0];
          });

          // Sort all resulting transactions by created_at (newest first)
          uniqueTransactions.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

          // Display the unique transactions
          uniqueTransactions.forEach(tx => {
            // Adjust timestamp for Singapore timezone (+8 hours)
            const txDate = new Date(tx.created_at);
            const sgDate = new Date(txDate.getTime() + (8 * 60 * 60 * 1000));

            // Format date for display in Singapore timezone
            const formattedDate = sgDate.toLocaleString('en-SG', {
              day: 'numeric',
              month: 'short',
              year: 'numeric',
              hour: '2-digit',
              minute: '2-digit',
              second: '2-digit',
              hour12: true
            });

            const transactionHtml = `
              <div class="border-bottom pb-2 mb-2">
                <div class="d-flex justify-content-between">
                  <strong>${tx.transaction_type === 'top_up' ? 'Top Up' : 'Payment'}</strong>
                  <span class="badge ${tx.status === 'completed' ? 'bg-success' : 'bg-warning'}">${tx.status}</span>
                </div>
                <div class="d-flex justify-content-between text-muted">
                  <small>${formattedDate}</small>
                  <span>$${(tx.amount / 100).toFixed(2)}</span>
                </div>
              </div>
            `;
            historyElement.innerHTML += transactionHtml;
          });
        }
      } catch (error) {
        console.error('Error loading transaction history:', error);
        const historyElement = document.getElementById('payment-history');
        historyElement.innerHTML = '<div class="text-center text-danger">Error loading transaction history</div>';
      }
    }

// Process URL parameters and refresh state on load (calls payment-service directly)
function processUrlParameters() {
      const urlParams = new URLSearchParams(window.location.search);
      const historyRefreshDelay = 3000; // Delay in milliseconds (e.g., 3 seconds)

      if (urlParams.has('success')) {
        // --- Task: Refresh only once on success AND add receipt message ---
        console.log("Processing successful payment redirect...");

        // Clear the success parameter from the URL bar
        window.history.replaceState({}, document.title, window.location.pathname);

        const sessionId = localStorage.getItem('session_id');
        const processedSessions = JSON.parse(localStorage.getItem('processed_sessions') || '[]');
        const statusElement = document.getElementById('payment-status');

        // --- ADDED RECEIPT MESSAGE to success alert ---
        statusElement.innerHTML =
          '<div class="alert alert-success">Payment successful! A receipt has been sent to your email. Refreshing data...</div>';
        // Note: For dynamic email, backend /success endpoint would need to return it.

        // Clear message after a longer period or let history load replace it
        setTimeout(() => {
          if (statusElement.innerHTML.includes('Payment successful')) { // Only clear if it wasn't replaced by an error
             statusElement.innerHTML = '';
          }
        }, 8000); // Increased timeout for the message

        // Check if this session was already processed
        if (sessionId && !processedSessions.includes(sessionId)) {
          processedSessions.push(sessionId);
          localStorage.setItem('processed_sessions', JSON.stringify(processedSessions));

          console.log(`Calling backend success endpoint for session: ${sessionId}`);
          // Call the backend's success endpoint
          fetch(`${PAYMENT_SERVICE_BASE_URL}/success?session_id=${sessionId}`)
            .then(response => {
              if (!response.ok) {
                throw new Error(`Error confirming success with backend: ${response.status}`);
              }
              return response.json();
            })
            .then(data => {
              console.log('Backend success endpoint confirmation:', data);
              // Optional: Use data if backend returns email, e.g., update receipt message
            })
            .catch(error => {
              console.error('Error calling backend success endpoint:', error);
              statusElement.innerHTML =
                '<div class="alert alert-warning">Payment successful, but backend confirmation failed. Data may be delayed.</div>';
            })
            .finally(() => {
               // --- DELAYED Refresh of balance and history ---
               console.log(`Refreshing balance and history after ${historyRefreshDelay}ms delay.`);
               setTimeout(() => {
                   console.log("Executing delayed refresh.");
                   refreshBalance();
                   loadTransactionHistory();
                   // Clear status message now that history is loading/loaded
                   if (statusElement.innerHTML.includes('successful') || statusElement.innerHTML.includes('delayed')) {
                      statusElement.innerHTML = '';
                   }
               }, historyRefreshDelay); // Apply the delay
            });

        } else if (!sessionId) {
            console.warn("Success redirect, but no session_id found in local storage.");
            // Still refresh data with delay even if session confirmation fails
             console.log(`Refreshing balance and history after ${historyRefreshDelay}ms delay (no session ID).`);
             setTimeout(() => {
                 console.log("Executing delayed refresh (no session ID).");
                 refreshBalance();
                 loadTransactionHistory();
                 if (statusElement.innerHTML.includes('successful')) { // Clear initial success message
                      statusElement.innerHTML = '';
                 }
             }, historyRefreshDelay);
        } else {
             console.log(`Session ${sessionId} already processed. Not auto-refreshing data.`);
             // Don't refresh again if session was already handled
             // You could still clear the success message if needed
              // setTimeout(() => {
              //   if (statusElement.innerHTML.includes('successful')) { statusElement.innerHTML = ''; }
              // }, 5000);
        }

        // Clean up session ID from local storage
        localStorage.removeItem('session_id');
        localStorage.removeItem('topup_amount');

      } else if (urlParams.has('canceled')) {
        // --- Handling Cancellation ---
        console.log("Processing canceled payment redirect...");
        window.history.replaceState({}, document.title, window.location.pathname);

        document.getElementById('payment-status').innerHTML =
          '<div class="alert alert-warning">Payment was canceled.</div>';

        setTimeout(() => {
          document.getElementById('payment-status').innerHTML = '';
        }, 5000);

        // Refresh data once on cancellation (no delay needed)
        refreshBalance();
        loadTransactionHistory();

      } else {
        // --- Initial Page Load (no success/cancel parameters) ---
        console.log("Initial page load, refreshing data.");
        // No delay needed for initial load
        refreshBalance();
        loadTransactionHistory();
      }
    } // --- End of processUrlParameters ---

    window.addEventListener('DOMContentLoaded', processUrlParameters);
  </script>
</body>
</html>